\section{Test-Framework}

\begin{frame}{Test-Framework}
Das Test-Framework wurde selbst implementiert. Es enthält diverse Funktionen zum automatisierten überprüfen der Testfälle.

\par \medskip

Tests werden in Korrekte und Falsche Testfälle unterschieden.


\end{frame}

\begin{frame}[fragile]
	\frametitle{Test-Suite: Token-Coverage \& Testfälle}
	
Die Test-Suite umfasst eine Token-Coverage von 100\%. 

\par \medskip

Zusätzlich umfasst die Test-Suite insgesamt 21 gültige und 12 ungültige Testfälle.

\par \medskip

Ungültige Testfälle werden in Syntaxfehler (Parser) und Typfehler (Typchecker) unterschieden.
\end{frame}

\begin{frame}{Test-Suite: Testfälle}

Jedes Testfile liegt in einem Ordner (Correct bzw. Wrong) mit zugehöriger .java-Datei. 	

\par \medskip

Ein Testfile besteht aus: 

\begin{itemize}
	\item Erwarteten Tokens
	\item Erwarteter abstrakter Syntax
	\item Erwarteter getypter abstrakter Syntax
\end{itemize}

Zusätzlich zum eigentlichen Testfile enthält der Ordner ein ClassFile in Haskell, mit der zu erwartenden Struktur des erzeugten Classfiles.
\end{frame}

\begin{frame}[fragile]
\frametitle{Test-Suite: Beispiel Testfile}
\begin{lstlisting}[language=Haskell]
module  Correct.EmptyClass.Steps where

import           ABSTree
import           Lexer.Token

emptyTokens = [Lexer.Token.CLASS,
              Lexer.Token.IDENTIFIER "Test",
              Lexer.Token.LEFT_BRACE,
              Lexer.Token.RIGHT_BRACE
              ]

emptyABS = [Class "Test" [] []]
emptyTypedABS = [Class "Test" [] []]	
\end{lstlisting}
	
\end{frame}

